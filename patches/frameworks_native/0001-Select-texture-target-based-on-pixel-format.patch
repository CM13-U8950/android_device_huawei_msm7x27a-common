From 7ed880deb77ee3d6ce6d3c6641abf27bfec15ff1 Mon Sep 17 00:00:00 2001
From: ksrt12 <kazakov12stepan2012@live.ru>
Date: Fri, 23 Sep 2016 12:08:53 +0300
Subject: [PATCH] Select texture target based on pixel format

Adreno is not optimized for GL_TEXTURE_EXTERNAL_OES, making GPU
utilization (and power), high with GL_TEXTURE_EXTERNAL_OES for
RGB formats.

Change texture target from GL_EXTERNAL_TEXTURE_OES to dynamically
select between GL_EXTERNAL_TEXTURE_OES, and GL_TEXTURE_2D based
on the pixel format.

This change is done to reduce the composition time for 8x55

Change-Id: I49e9c7df6830f490a42a0f68fc39a022f43c7d8c
---
 include/gui/GLConsumer.h                           |  8 +++++-
 libs/gui/Android.mk                                |  4 +++
 services/surfaceflinger/Android.mk                 |  4 +++
 services/surfaceflinger/Layer.cpp                  |  5 ++++
 .../RenderEngine/GLES11RenderEngine.cpp            | 24 ++++++++++++++++
 services/surfaceflinger/SurfaceFlingerConsumer.cpp | 33 ++++++++++++++++++++++
 services/surfaceflinger/SurfaceFlingerConsumer.h   | 10 ++++++-
 7 files changed, 86 insertions(+), 2 deletions(-)

diff --git a/include/gui/GLConsumer.h b/include/gui/GLConsumer.h
index e03de45..3b99ed4 100644
--- a/include/gui/GLConsumer.h
+++ b/include/gui/GLConsumer.h
@@ -429,7 +429,13 @@ private:
     // glCopyTexSubImage to read from the texture.  This is a hack to work
     // around a GL driver limitation on the number of FBO attachments, which the
     // browser's tile cache exceeds.
-    const uint32_t mTexTarget;
+#ifdef DECIDE_TEXTURE_TARGET
+     protected:
+     uint32_t mTexTarget;
+     private:
+#else
+     const uint32_t mTexTarget;
+#endif
 
     // EGLSlot contains the information and object references that
     // GLConsumer maintains about a BufferQueue buffer slot.
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index 9770da2..587ca32 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -72,6 +72,10 @@ ifeq ($(TARGET_SAMSUNG_GRALLOC_EXTERNAL_USECASES),true)
 	LOCAL_CFLAGS += -DSAMSUNG_GRALLOC_EXTERNAL_USECASES
 endif
 
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+	LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 ifeq (,$(ONE_SHOT_MAKEFILE))
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index f9a6852..7361907 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -93,6 +93,10 @@ else
     LOCAL_CFLAGS += -DMAX_VIRTUAL_DISPLAY_DIMENSION=0
 endif
 
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+    LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
+endif
+
 LOCAL_CFLAGS += -fvisibility=hidden -Werror=format
 LOCAL_CFLAGS += -std=c++11
 
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index 0d8b009..17882be 100755
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -1419,8 +1419,13 @@ Region Layer::latchBuffer(bool& recomputeVisibleRegions)
         Reject r(mDrawingState, getCurrentState(), recomputeVisibleRegions,
                 getProducerStickyTransform() != 0);
 
+#ifdef DECIDE_TEXTURE_TARGET
+        status_t updateResult = mSurfaceFlingerConsumer->updateTexImage(&r,
+                mFlinger->mPrimaryDispSync, &mTexture);
+#else
         status_t updateResult = mSurfaceFlingerConsumer->updateTexImage(&r,
                 mFlinger->mPrimaryDispSync);
+#endif
         if (updateResult == BufferQueue::PRESENT_LATER) {
             // Producer doesn't want buffer to be displayed yet.  Signal a
             // layer update so we check again at the next opportunity.
diff --git a/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp b/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp
index 22096ad..c63426c 100644
--- a/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp
+++ b/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp
@@ -208,8 +208,14 @@ void GLES11RenderEngine::setupLayerTexturing(const Texture& texture) {
     glMatrixMode(GL_TEXTURE);
     glLoadMatrixf(texture.getMatrix().asArray());
     glMatrixMode(GL_MODELVIEW);
+#ifdef DECIDE_TEXTURE_TARGET
+    glDisable((target == Texture::TEXTURE_2D) ?
+            GL_TEXTURE_EXTERNAL_OES : GL_TEXTURE_2D);
+    glEnable(target);
+#else
     glDisable(GL_TEXTURE_2D);
     glEnable(GL_TEXTURE_EXTERNAL_OES);
+#endif
 }
 
 void GLES11RenderEngine::setupLayerBlackedOut() {
@@ -217,13 +223,25 @@ void GLES11RenderEngine::setupLayerBlackedOut() {
     glMatrixMode(GL_TEXTURE);
     glLoadIdentity();
     glMatrixMode(GL_MODELVIEW);
+#ifdef DECIDE_TEXTURE_TARGET
+    glDisable((target == Texture::TEXTURE_2D) ?
+            GL_TEXTURE_EXTERNAL_OES : GL_TEXTURE_2D);
+    glEnable(target);
+#else
     glDisable(GL_TEXTURE_EXTERNAL_OES);
     glEnable(GL_TEXTURE_2D);
+#endif
 }
 
 void GLES11RenderEngine::disableTexturing() {
+#ifdef DECIDE_TEXTURE_TARGET
+    glDisable((target == Texture::TEXTURE_2D) ?
+            GL_TEXTURE_EXTERNAL_OES : GL_TEXTURE_2D);
+    glEnable(target);
+#else
     glDisable(GL_TEXTURE_EXTERNAL_OES);
     glDisable(GL_TEXTURE_2D);
+#endif
 }
 
 void GLES11RenderEngine::disableBlending() {
@@ -274,8 +292,14 @@ void GLES11RenderEngine::unbindFramebuffer(uint32_t texName, uint32_t fbName,
 
 void GLES11RenderEngine::setupFillWithColor(float r, float g, float b, float a) {
     glColor4f(r, g, b, a);
+#ifdef DECIDE_TEXTURE_TARGET
+    glDisable((target == Texture::TEXTURE_2D) ?
+            GL_TEXTURE_EXTERNAL_OES : GL_TEXTURE_2D);
+    glEnable(target);
+#else
     glDisable(GL_TEXTURE_EXTERNAL_OES);
     glDisable(GL_TEXTURE_2D);
+#endif
     glDisable(GL_BLEND);
 }
 
diff --git a/services/surfaceflinger/SurfaceFlingerConsumer.cpp b/services/surfaceflinger/SurfaceFlingerConsumer.cpp
index 7de6ac4..54fd442 100644
--- a/services/surfaceflinger/SurfaceFlingerConsumer.cpp
+++ b/services/surfaceflinger/SurfaceFlingerConsumer.cpp
@@ -25,13 +25,24 @@
 #include <utils/NativeHandle.h>
 #include <utils/Trace.h>
 
+#ifdef DECIDE_TEXTURE_TARGET
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+#endif
+
 namespace android {
 
 // ---------------------------------------------------------------------------
 
+#ifdef DECIDE_TEXTURE_TARGET
+status_t SurfaceFlingerConsumer::updateTexImage(BufferRejecter* rejecter,
+        const DispSync& dispSync, Texture* mTexture)
+{
+#else
 status_t SurfaceFlingerConsumer::updateTexImage(BufferRejecter* rejecter,
         const DispSync& dispSync)
 {
+#endif
     ATRACE_CALL();
     ALOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
@@ -75,6 +86,28 @@ status_t SurfaceFlingerConsumer::updateTexImage(BufferRejecter* rejecter,
         return NO_ERROR;
     }
 
+#ifdef DECIDE_TEXTURE_TARGET
+    // GPU is not efficient in handling GL_TEXTURE_EXTERNAL_OES
+    // texture target. Depending on the image format, decide,
+    // the texture target to be used
+    if (mTexture) {
+        switch (mSlots[buf].mGraphicBuffer->format) {
+            case HAL_PIXEL_FORMAT_RGBA_8888:
+            case HAL_PIXEL_FORMAT_RGBX_8888:
+            case HAL_PIXEL_FORMAT_RGB_888:
+            case HAL_PIXEL_FORMAT_RGB_565:
+            case HAL_PIXEL_FORMAT_BGRA_8888:
+                mTexture->init(Texture::TEXTURE_2D, mTexture->getTextureName());
+                mTexTarget = GL_TEXTURE_2D;
+                break;
+            default:
+                mTexture->init(Texture::TEXTURE_EXTERNAL, mTexture->getTextureName());
+                mTexTarget = GL_TEXTURE_EXTERNAL_OES;
+                break;
+        }
+    }
+#endif
+
     // Release the previous buffer.
     err = updateAndReleaseLocked(item);
     if (err != NO_ERROR) {
diff --git a/services/surfaceflinger/SurfaceFlingerConsumer.h b/services/surfaceflinger/SurfaceFlingerConsumer.h
index 28f2f6a..2a76d11 100644
--- a/services/surfaceflinger/SurfaceFlingerConsumer.h
+++ b/services/surfaceflinger/SurfaceFlingerConsumer.h
@@ -20,6 +20,10 @@
 #include "DispSync.h"
 #include <gui/GLConsumer.h>
 
+#ifdef DECIDE_TEXTURE_TARGET
+#include "RenderEngine/Texture.h"
+#endif
+
 namespace android {
 // ----------------------------------------------------------------------------
 
@@ -53,8 +57,12 @@ public:
     // reject the newly acquired buffer.  Unlike the GLConsumer version,
     // this does not guarantee that the buffer has been bound to the GL
     // texture.
+#ifdef DECIDE_TEXTURE_TARGET
+    status_t updateTexImage(BufferRejecter* rejecter, const DispSync& dispSync,
+            Texture* mTexture = 0);
+#else
     status_t updateTexImage(BufferRejecter* rejecter, const DispSync& dispSync);
-
+#endif
     // See GLConsumer::bindTextureImageLocked().
     status_t bindTextureImage();
 
-- 
2.9.3

